#Algorithms

Вы можете думать о диапазоне как о двух итераторах, которые ссылаются на начало и конец группы элементов, которые можно перебирать. Поскольку все контейнеры поддерживают итераторы, каждый контейнер можно рассматривать как диапазон. Поскольку все алгоритмы из Boost.Range ожидают диапазона в качестве первого параметра, контейнер `Std :: vector` может быть передан непосредственно. Вам не нужно вызывать `begin()` и `end()`, а затем передать два итератора отдельно. Это защищает вас от ошибок, таких как передача итераторов begin()` и `end() в неправильном порядке или передачи итераторов, которые принадлежат двум разным контейнерам.

<a name="ex.graph_01"/>
Пример 30.1. Считаем с помощью `boost::count()`
```c++
#include <boost/range/algorithm.hpp>
#include <array>
#include <iostream>

int main()
{
  std::array<int, 6> a{{0, 1, 0, 1, 0, 1}};
  std::cout << boost::count(a, 0) << '\n';
}
```


[Пример 30.1](#ex.graph_01) использует алгоритм `boost :: count ()`, который определен в `boost / range / algorithm.hpp`. Этот заголовочный файл обеспечивает доступ ко всем алгоритмам, для которых существуют аналоги в заголовочном файле стандартной библеотеки `algorithm`.

Все алгоритмы из Boost.Range требуют , чтобы первый параметр был диапазоном. Объект типа `Std :: array` может быть передан в Boost :: Count () напрямую, так как контейнеры являются диапазоном. Поскольку `Boost :: count ()` эквивалентно `Std :: count ()`, вы должны передать в значение,с которым будут сравниваться элементы диапазона.

В [Примере 30.1](#ex.graph_01), **a** содержит три 0 , так **3** записывается в стандартный поток вывода.

[Пример 30.2](#ex.graph_02) представляет больше алгоритмов, которые, как `Boost :: COUNT ()`, аналогичны алгоритмам из стандартной библиотеки.

<a name="ex.graph_01"/>
Пример 30.2. Range алгоритмы, связанные с алгоритмами из стандартной библиотеки
```c++
#include <boost/range/algorithm.hpp>
#include <boost/range/numeric.hpp>
#include <array>
#include <iterator>
#include <iostream>

int main()
{
  std::array<int, 6> a{{0, 1, 2, 3, 4, 5}};
  boost::random_shuffle(a);
  boost::copy(a, std::ostream_iterator<int>{std::cout, ","});
  std::cout << "\n" << *boost::max_element(a) << '\n';
  std::cout << boost::accumulate(a, 0) << '\n';
}
```

`boost :: random_shuffle ()` работает как `std :: random_shuffle ()`, изменяя порядок элементов в диапазоне случайным образом. [Пример 30.2](#ex.graph_02) использует `boost :: random_shuffle ()` генератор случайных чисел по умолчанию. Тем не менее, вы можете передать генератор случайных чисел в качестве второго параметра. Это может быть генератор случайных чисел либо из файла заголовка C ++ 11 `random` или из Boost.Random.


